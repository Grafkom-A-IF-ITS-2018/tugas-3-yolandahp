<!DOCTYPE html>
<html>
    <head>
        <title>
            Tugas 3 Grafkom
        </title>
        <script type="text/javascript" src="gl-matrix-min.js"></script>
        <script src="CollisionDetector.js"></script>
        <script src="Geometry.js"></script>
        <script src="Cube.js"></script>
        <script src="LetterL.js"></script>
        <script src="Utils.js"></script>
        <script src="main.js"></script>
        
        <script type="x-shader/x-fragment" id="shader-fs">
            precision mediump float;
            
            varying vec2 vTextureCoord;
            varying vec4 vColor;
            varying vec3 vLight;

            uniform sampler2D uSampler;
            uniform float uAlpha;

            void main(void){
                vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                gl_FragColor = vColor + vec4(textureColor.rgb * vLight, textureColor.a * uAlpha);
            }
        </script>
        <script type="x-shader/x-vertex" id="shader-vs">
            attribute vec3 aVertexPosition;
            attribute vec4 aVertexColor;
            attribute vec3 aVertexNormal;
            attribute vec2 aVertexTexCoord;

            uniform mat3 uNormalMatrix;
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            uniform vec3 uAmbientColor;
            uniform vec3 uPointLightingLoc;
            uniform vec3 uPointLightingColor;

            uniform bool uUseLighting;
            uniform float uShine;

            varying vec2 vTextureCoord;
            varying vec3 vLight;
            varying vec4 vColor;
            
            void main(void){
                vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);

                gl_Position = uPMatrix * mvPosition;
                vTextureCoord = aVertexTexCoord;
                vColor = aVertexColor;
        

                if(!uUseLighting){
                    vLight = vec3(1.0, 1.0, 1.0);
                } else{
                    vec3 lightDirection = normalize(uPointLightingLoc - mvPosition.xyz);
                    vec3 transformedNormal = uNormalMatrix * aVertexNormal;

                    float res = dot(transformedNormal, lightDirection);
                    if(res < 0.0) res = -res;
                    float directionalLight = max(pow(res, uShine), 0.0);
                    vLight = uAmbientColor + uPointLightingColor * directionalLight;
                }
            }
        </script>
    </head>
    <body>
        <canvas id="mycanvas" style="border:none" width="1600" height="800" align="center"></canvas>
        <script type="text/javascript">
            var cont = new WebGL('mycanvas');

            let boxCrate = new Cube(24, 24, 24, 2);
            boxCrate.rotation.y = 135;
            boxCrate.rotation.x = 90;
            boxCrate.addTexture('Crate.jpg');
            boxCrate.render();
            cont.addBuffer(boxCrate);

            let r = new RGeometry();
            r.rotation.y = 45;
            r.action = () => {
                r.matrixWorld = Object.assign({},r.temporaryMatrixWorld);
                r.move.vector([window.dir[0]*0.1, window.dir[1]*0.1, window.dir[2]*0.1]);
                r.rotation.y += window.rotater*0.5;
                r.translate.mat = [-1.5, -3.0, -0.5];
            };

            r.render();
            cont.addBuffer(r);

            let ambientLight = new AmbientLight(new Color("0xFFFFFF"));
            cont.addBuffer(ambientLight);

            let pointLight = new PointLight(new Color("0x156289"), {x:0, y:5, z:-35});
            cont.addBuffer(pointLight);

            const tick = () => {
                requestAnimationFrame(tick);
                cont.renderScene();
            }

            document.addEventListener('after-render', function(){
                let collisionDetector = new CollisionDetector(boxCrate, r);
                collisionDetector.buildCollider();
                collisionDetector.detect();
            });

            document.addEventListener('light-follow', function(){
                let center = r.findCenter();
                pointLight.position.x = center[0];
                pointLight.position.y = center[1];
                pointLight.position.z = center[2];
            })

            tick();

        </script>
    
    </body>
</html>